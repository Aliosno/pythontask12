# Каждый объект при создании получает некоторое значение идентичности,
# и оно не может измениться у одного конкретного объекта во время выполнения программы.
L = ['a', 'b', 'c']
print(id(L))

L.append('d')
print(id(L))
#Рассмотренное нами свойство уникальности каждого объекта используется,
# в том числе для сравнения объектов с помощью ключевого слова is.

list_1 = ['a', 'b', 'c']
list_2 = list_1
list_3 = list(list_1)
print(list_1)
print(list_2)
print(list_3)
# Затем проверяем равенство этих списков:

print(list_1 == list_2)
print(list_1 == list_3)
#«==», если объекты, на которые ссылаются переменные, равны.
print(list_1 is list_2)
print(list_1 is list_3)
#Здесь мы можем увидеть (list_1 is list_3) False,
# потому что list_1 и list_3 указывают на два разных объекта,
# даже если их содержимое может быть одинаковым.

#При работе со списками есть особенность, которую необходимо рассмотреть.

L = ['Hello', 'world']
M = L

print(M is L)
# True

#Очевидно, что эти списки будут равны по своим значениям (сравнивая через ==).
# И при таком присваивании в M скопируется не сам список L, а его идентификатор!
# Поэтому, изменяя список M, мы увидим неожиданные изменения в списке L.

M.append('!')

print(L)
# ['Hello', 'world', '!']

#Чтобы избежать такого поворота событий, список нужно копировать.

M = L.copy()

print(M is L)
# False

# Можно создать список (list) внутри самого кортежа:

shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])

shopping_center[-1].append("Uniqlo")

print(shopping_center)
# ('Галерея', 'Санкт-Петербург', 'Лиговский пр., 30', ['H&M', 'Zara', 'Uniqlo'])

#Изменение списка внутри кортежа не привело к ошибке,
# потому что уникальный идентификатор этого списка остался неизменным.

shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])
list_id_before = id(shopping_center[-1])

shopping_center[-1].append("Uniqlo")
list_id_after = id(shopping_center[-1])

print(list_id_before == list_id_after)